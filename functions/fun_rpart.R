#' Function to analyze microsimulation data with recursive partitioning
#' and determine optimal treatment assignment based on classification tree
#' Input: 
#' 1. Requires a decision rule model structure generated by fun_opt_treat
#' 2. Desired number of splits in tree
#' 3. Vector of treatments
#' 4. Number of simulations in the microsimulation

fun_rpart <- function(dec_rules, des_split, treatments, nsim){
  
  # Create an empty list
  dec_rules$rpart <- list()
  
  # Log start time
  dec_rules$rpart$time$start <- Sys.time()
  
  # Create a new data frame out both covariates (X) and treatment (W)
  dec_rules$rpart$X_W <- cbind(data.frame(dec_rules$X)[1:nrow(dec_rules$PRC),], dec_rules$opt_treat$OPTIMAL)
  
  # Rename columns
  colnames(dec_rules$rpart$X_W) <- c(dec_rules$covariates, "Treatment")
  
  # Turn treatment into factor
  dec_rules$rpart$X_W$Treatment <- as.factor(dec_rules$rpart$X_W$Treatment)
  # dec_rules$rpart$X_W$Treatment <- as.numeric(dec_rules$rpart$X_W$Treatment)
  
  # Run initial rpart to determine the appropriate complexity
  rpart_initial <- rpart(Treatment ~ baseline_abr_ind + age + sex, 
                                      data = dec_rules$rpart$X_W, 
                                      method = "class",
                                      cp = 0.0001)
  
  # Select complexity based on number of splits selected by user
  
  closest_row <- which.min(abs(rpart_initial$cptable[, "nsplit"] - des_split))
  
  cp <- rpart_initial$cptable[closest_row,"CP"] + 0.0000000001

  # Run rpart
  dec_rules$rpart$tree_model <- rpart(Treatment ~ baseline_abr_ind + age + sex, 
                                      data = dec_rules$rpart$X_W, 
                                      method = "class",
                                      cp = cp)
  
  # Predict treatment based on recursive partitioning
  dec_rules$rpart$predicted <- predict(dec_rules$rpart$tree_model, type = "class")
  
  
  for (i in 1:dec_rules$ntreat) {
    
    # Which patients should receive treatment i?
    predict_treat <- which(dec_rules$rpart$predicted == treatments[i])
    
    if (length(predict_treat) > 0) {
      dec_rules[["patient_NMB"]][predict_treat,"RECURSIVE_PARTITIONING"]  <- dec_rules[["PRC"]][predict_treat, paste0(treatments[i],"_NMB")]
      dec_rules[["patient_QALY"]][predict_treat,"RECURSIVE_PARTITIONING"]  <- dec_rules[["PRC"]][predict_treat, paste0(treatments[i],"_QALYs_disc")]
      dec_rules[["patient_COST"]][predict_treat,"RECURSIVE_PARTITIONING"]  <- dec_rules[["PRC"]][predict_treat, paste0(treatments[i],"_cost_disc")]
      
    }
  }
  
  #===============================================================================
  # Comparison Table
  #===============================================================================
  # Add row to comparison table
  
  dec_rules$rpart$mean_outcomes <- setNames(data.frame(matrix(data = 0,
                                                              nrow = 1,
                                                              ncol = 3)),
                                            c("QALYs", "Costs", "NMB"))
  
  rownames(dec_rules$rpart$mean_outcomes) <- "RECURSIVE_PARTITIONING"
  
  dec_rules$rpart$mean_outcomes[1,"QALYs"] <- mean(dec_rules[["patient_QALY"]][["RECURSIVE_PARTITIONING"]])
  dec_rules$rpart$mean_outcomes[1,"Costs"] <- mean(dec_rules[["patient_COST"]][["RECURSIVE_PARTITIONING"]])
  dec_rules$rpart$mean_outcomes[1,"NMB"]   <- mean(dec_rules[["patient_NMB"]][["RECURSIVE_PARTITIONING"]])
  
  dec_rules$comp_table <- rbind (dec_rules$comp_table, dec_rules$rpart$mean_outcomes)
  
  #===============================================================================
  # Decision rules and Plot
  #===============================================================================
  
  dec_rules$rpart$rules <- rpart.rules(dec_rules$rpart$tree_model, 
                                       style = "wide", 
                                       nn = TRUE,
                                       cover = TRUE,
                                       varorder=c("baseline_abr_ind", "age", "sex") )
  
  ## We use this plot to extract certain information about tree
  plot <- prp(dec_rules$rpart$tree_model, type = 4, varlen = 0, nn = TRUE )
  
  #===============================================================================
  # Custom frame for probabilistic analysis
  #===============================================================================
  
  # Extract tree
  fit <- dec_rules$rpart$tree_model
  
  # Extract the frame component
  frame <- dec_rules$rpart$tree_model$frame
  
  # Only keep relevant columns
  frame <- frame[,names(frame) %in% c("var", "n")]
  
  # Add the treatment names to nodes
  frame <- cbind(frame, plot[["labs"]]) 
  
  # Change volumn names
  colnames(frame) <- c("var", "n", "treatment")
  
  # Extract the variable names used for splits
  non_terminal_nodes <- frame[frame$var != "<leaf>", ]
  
  # Order by row name, which is the node number
  non_terminal_nodes <- non_terminal_nodes[order(as.numeric(row.names(non_terminal_nodes))), ]
  split_vars <- as.character(non_terminal_nodes$var)
  
  # Initialize a list to store the split values
  split_values <- list()
  
  # Loop through non-terminal nodes to extract split details
  for (i in 1:nrow(non_terminal_nodes)) {
    
    var_rows <- which(row.names(fit$splits) == split_vars[i])
    
    count_rows <- which(non_terminal_nodes[i,]$n == fit$splits[,"count"])
    
    intersect <- intersect(var_rows, count_rows)
    
    non_terminal_nodes[i, "index"] <- fit$splits[intersect,"index"]
    
    original_row <- which(row.names(non_terminal_nodes[i, ]) == row.names(frame))
    
    frame[original_row, "index"] <- non_terminal_nodes[i, "index"]
    
  }
  
  # Order by node number
  frame <-  frame[order(as.numeric(row.names(frame))), ]
  
  # Determine the paths by which nodes are reached
  paths <- path.rpart(fit, nodes = rownames(frame), pretty = 0)
  
  # Determine left and right split node destinations for each node
  for (i in 1:nrow(frame)) {
    
    if (frame[i,"var"] != "<leaf>") {
      frame[i,"left"]  <- as.numeric(row.names(frame[i,])) * 2
      frame[i,"right"] <- frame[i,"left"] + 1
    } else {
      frame[i,"left"]  <- NA
      frame[i,"right"] <- NA
    }
    
  }
  
  # Determine whether left split is based on greater than or lesser than condition
  
  for (i in 1:nrow(frame)) {
    
    if (frame[i,"var"] != "<leaf>") {
      
      left <- as.character(frame[i,"left"])
      string <- paths[[left]][[length(paths[[left]])]]
      
      if (grepl(">=", string, fixed = TRUE)) {
        
        frame[i,"condition"] <- ">="
        
      } else {
        
        frame[i,"condition"] <- "<"
        
      }
      
    } else {
      frame[i,"condition"] <- NA
    }
    
  }
  
  # Create empty matrix and assign names
  node_assignment <- data.frame(matrix(FALSE, 
                                       nrow = nrow(dec_rules$rpart$X_W), 
                                       ncol = length(row.names(frame))))
  
  colnames(node_assignment) <- row.names(frame)
  
  # Every patient is in node 1 by definition
  
  node_assignment[,"1"] <- TRUE
  
  for (i in 1:ncol(node_assignment)) {
    
    if (frame[i, "var"] != "<leaf>") {
      
      # We construct the rule which determines whether someone is split into the
      # left or the right node
      var   <- frame[i, "var"] 
      cond  <- frame[i, "condition"]
      index <- frame[i, "index"]
      left  <- frame[i, "left"]
      right <- frame[i, "right"] 
      
      if (cond == "<") {
        
        which_left  <- which((dec_rules$rpart$X_W[,var] < index) & (node_assignment[,i] == TRUE)) 
        which_right <- which((dec_rules$rpart$X_W[,var] >= index) & (node_assignment[,i] == TRUE)) 
        
      } else if (cond == ">=") {
        
        which_left  <- which((dec_rules$rpart$X_W[,var] >= index) & (node_assignment[,i] == TRUE)) 
        which_right <- which((dec_rules$rpart$X_W[,var] < index) & (node_assignment[,i] == TRUE)) 
        
      }
      
      node_assignment[which_left,paste0(left)]   <- TRUE
      node_assignment[which_right,paste0(right)] <- TRUE
      
    }
    
    frame[i, "n_doublecheck"] <- sum(node_assignment[,i])
    
  }
  
  # Save results
  dec_rules$rpart$node_assignment <- node_assignment
  dec_rules$rpart$frame <- frame
  
  #===============================================================================
  # End
  #===============================================================================
  
  # Log end time
  dec_rules$rpart$time$end <- Sys.time()
  
  # Calculate runtime in seconds
  dec_rules$rpart$time$duration <- as.numeric(dec_rules$rpart$time$end, units = "secs") - as.numeric(dec_rules$rpart$time$start, units = "secs")
  
  # Return list with output
  return(dec_rules)
  
}
  