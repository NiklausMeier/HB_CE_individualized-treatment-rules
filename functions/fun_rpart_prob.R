#' Function to analyze the input parameter uncertainty of the decision rules
#' from recursive partitioning, based on probabilistic analysis.
#' Input: 
#' 1. Requires a decision rule model structure generated by fun_opt_treat

fun_rpart_prob <- function(dec_rules){
  
  #===============================================================================
  # Create new trees based on combinations of decision variables
  #===============================================================================
  print("Create new trees based on combinations of decision variables")
  
  dec_rules$rpart$prob <- list()
  
  # Create empty 3-dimensional array and assign names
  # Dimension 1 (Rows): Patients
  # Dimension 2 (Columns): Decision tree nodes
  # Dimension 3 (Depth): Combinations of threshold values
  
  node_assignment <- array(FALSE,
                           dim=c(nrow(dec_rules$rpart$X_W), length(row.names(dec_rules$rpart$frame)), nrow(dec_rules$rpart$combinations)),
                           dimnames = list(1: nrow(dec_rules$rpart$X_W),
                                           row.names(dec_rules$rpart$frame),
                                           1:nrow(dec_rules$rpart$combinations)))
  
  # Every patient for all combinations is in node 1 by definition
  node_assignment[,"1",] <- TRUE
  
  # Create a matrix for treatment assignment
  treatment_assignment <- data.frame(matrix(0, 
                                            nrow = nrow(dec_rules$rpart$X_W), 
                                            ncol = nrow(dec_rules$rpart$combinations)))
  
  colnames(treatment_assignment) <- row.names(dec_rules$rpart$combinations)
  
  # Progress bar
  pb = txtProgressBar(min = 0, max = dim(node_assignment)[3], initial = 0) 
  
  for (j in 1:dim(node_assignment)[3]) {
    
    gc()
    
    setTxtProgressBar(pb,j)
    
    for (i in 1:ncol(node_assignment)) {
      
      # If not a final leaf, check whether patient is assigned to left or right next node
      if (dec_rules$rpart$frame[i, "var"] != "<leaf>") {
        
        # We construct the rule which determines whether someone is split into the
        # left or the right node
        var   <- dec_rules$rpart$frame[i, "var"] 
        cond  <- dec_rules$rpart$frame[i, "condition"]
        left  <- dec_rules$rpart$frame[i, "left"]
        right <- dec_rules$rpart$frame[i, "right"] 
        index <- dec_rules$rpart$combinations[j,var]
        
        if (cond == "<") {
          
          which_left  <- which((dec_rules$rpart$X_W[,var] < index) & (node_assignment[,i,j] == TRUE)) 
          which_right <- which((dec_rules$rpart$X_W[,var] >= index) & (node_assignment[,i,j] == TRUE)) 
          
        } else if (cond == ">=") {
          
          which_left  <- which((dec_rules$rpart$X_W[,var] >= index) & (node_assignment[,i,j] == TRUE)) 
          which_right <- which((dec_rules$rpart$X_W[,var] < index) & (node_assignment[,i,j] == TRUE)) 
          
        }
        
        node_assignment[which_left,paste0(left),j]   <- TRUE
        node_assignment[which_right,paste0(right),j] <- TRUE
        
        # If this is a final leaf, check if TRUE, as that determines treatment assignment
      } else if (dec_rules$rpart$frame[i, "var"] == "<leaf>") {
        
        treatment   <- dec_rules$rpart$frame[i, "treatment"]
        
        which_treat <- which(node_assignment[,i,j] == TRUE)
        
        treatment_assignment[which_treat,j] <- treatment
        
      }
    }
  }
  
  close(pb)
  
  dec_rules$rpart$prob$node_assignment      <- node_assignment
  dec_rules$rpart$prob$treatment_assignment <- treatment_assignment
  
  #===============================================================================
  # Check how often the right treatment was assigned to each patient
  #===============================================================================
  
  treat_prediction_accuracy <- vector()
  
  for (i in 1:dim(node_assignment)[3]) {
    treat_prediction_accuracy[i] <- count(dec_rules$rpart$prob$treatment_assignment[,i] == dec_rules[["opt_treat"]][["OPTIMAL"]])[[2]][[2]]
  } 
  
  dec_rules$rpart$prob$treat_prediction_accuracy <- treat_prediction_accuracy
  
  #===============================================================================
  # Determine treatment assignment based on new trees
  #===============================================================================
  print("Determine treatment assignment based on new trees")
  
  # For the total number of simulations, create that number of empty lists
  dec_rules$rpart$prob$sims <- vector(mode = "list", length = nloops * model$struct$nsim)
  
  simSize = nrow(dec_rules$PRC)/(nloops * model$struct$nsim)
  
  # Progress bar
  pb = txtProgressBar(min = 0, max = nloops * model$struct$nsim, initial = 0) 
  
  for (i in 1:(nloops * model$struct$nsim)) {
    
    gc()
    
    setTxtProgressBar(pb,i)
    
    # Define start and end of a given patient subsample out of the total dataset
    simStart = ((i-1) * simSize + 1)
    simEnd = (i * simSize)
    
    # Create a new data frame out both covariates (X) and optimal treatment (W)
    dec_rules$rpart$prob$sims[[i]]$X_W <- cbind(data.frame(dec_rules$X)[simStart : simEnd, ], 
                                           dec_rules$opt_treat$OPTIMAL[simStart : simEnd])
    
    # Rename columns
    colnames(dec_rules$rpart$prob$sims[[i]]$X_W) <- c(dec_rules$covariates, "Treatment")
    
    # Extract which tree variable combinations lead to which treatment assignments
    dec_rules$rpart$prob$sims[[i]]$var_treat_assign <- treatment_assignment[simStart : simEnd,]
    
    # See how accurate each combination of treatment decision variables is
    treat_prediction_accuracy <- vector()
    
    for (j in 1:dim(node_assignment)[3]) {
      
      var_treat_assign <- dec_rules$rpart$prob$sims[[i]]$var_treat_assign[,j]
      
      opt_treat <- dec_rules[["rpart"]][["prob"]][["sims"]][[i]][["X_W"]][["Treatment"]]
      
      count <- count(var_treat_assign == opt_treat)
      
      which <- which(count[,"x"] == TRUE)
      
      treat_prediction_accuracy[j] <- count[which,2]
      
    } 
    
    # Save the treatment prediction accuracy
    dec_rules$rpart$prob$sims[[i]]$treat_prediction_accuracy <- treat_prediction_accuracy
    
    # Which variable combinations maximize prediction accuracy?
    dec_rules$rpart$prob$sims[[i]]$max_treat_pred_acc <- which(treat_prediction_accuracy == max(treat_prediction_accuracy))
    
    # In some cases, multiple variable combinations can be tied for prediction accuracy
    # In those cases, we look for the combinations with the smallest deviation from the globally optimal combination
    
    which_pred <- dec_rules$rpart$prob$sims[[i]]$max_treat_pred_acc
    
    which <- which(dec_rules[["rpart"]][["combinations_diff"]][which_pred] == min(dec_rules[["rpart"]][["combinations_diff"]][which_pred]))
    
    dec_rules$rpart$prob$sims[[i]]$max_treat_pred_acc <- which_pred[which]
    
  }
  
  close(pb)
  
  #===============================================================================
  # Evaluate what the lowest and highest optimal values are
  #===============================================================================
  
  # In a vector, store what the best combination was in each individual simulation
  dec_rules$rpart$prob$best_combination <- vector()
  
  for (i in 1:length(dec_rules$rpart$prob$sims)) {
    
    dec_rules$rpart$prob$best_combination[i] <- dec_rules$rpart$prob$sims[[i]]$max_treat_pred_acc[1]
    
  }
  
  # Which variables do these combinations imply?
  dec_rules$rpart$prob$best_combination_vars <- dec_rules$rpart$combinations[dec_rules$rpart$prob$best_combination,]
  
  # Create empty vectors to hold minimum and maximum of variable values
  dec_rules$rpart$prob$best_combination_vars_min <- vector()
  dec_rules$rpart$prob$best_combination_vars_max <- vector()
  
  for (i in 1:ncol(dec_rules$rpart$combinations)) {
    
    dec_rules$rpart$prob$best_combination_vars_min[i] <- min(dec_rules$rpart$prob$best_combination_vars[,i])
    dec_rules$rpart$prob$best_combination_vars_max[i] <- max(dec_rules$rpart$prob$best_combination_vars[,i])
    
  }
  
  # Name the vector entries
  names(dec_rules$rpart$prob$best_combination_vars_min) <- colnames(dec_rules$rpart$combinations)
  names(dec_rules$rpart$prob$best_combination_vars_max) <- colnames(dec_rules$rpart$combinations)
  
  #===============================================================================
  # End
  #===============================================================================
  
  # Return list with output
  
  return(dec_rules)
  
}
