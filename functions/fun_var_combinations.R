# This function creates a matrix of all possible variable combinations
# of all thresholds found in the recursive partitioned decision tree.
# In this matrix, each row is one combination of unique values for
# each decision node in the tree

# To restrict the range of values considered, we multiply the lowest value found in the tree
# by a lower_bound parameter, and we multiply the highest value found in the tree
# by an upper_bound parameter

#' Input: 
#' 1. Requires a decision rule model structure generated by fun_opt_treat
#' 2. Lower percentile of range of values
#' 3. Upper percentile of range of values

fun_var_combinations <- function(dec_rules, lower_percentile, upper_percentile){
  
  #===============================================================================
  # Determine all sequences of individual variable values to be considered
  #===============================================================================
  
  # Only include vars found in decision nodes, not final leaves
  vars <- which(dec_rules[["rpart"]][["frame"]][["var"]] != "<leaf>")
  vars_n <- length(vars)
  # What are the names of these leaves?
  vars_names <- dec_rules[["rpart"]][["frame"]][["var"]][vars]
  
  # Create a list of vectors to contain variable value sequences
  dec_rules$rpart$var_seq <- vector(mode = "list", length = length(vars))
  names(dec_rules$rpart$var_seq) <- vars_names
  
  for (i in 1:vars_n) {
    
    # Where does this variable actually show up in the frame?
    which <- which(dec_rules$rpart$frame$var == vars_names[i])
    
    # Determine lower and upper bound for the variable
    min <- quantile(dec_rules[["X"]][,vars_names[i]], lower_percentile)
    max <- quantile(dec_rules[["X"]][,vars_names[i]], upper_percentile)
    
    # Create a vector for each variable, containing the individual values
    dec_rules$rpart$var_seq[[i]] <- vector()
    dec_rules$rpart$var_seq[[i]] <- seq(from = min, to = max, by = 1)
    
  }
  
  #===============================================================================
  # Find all possible combinations of variables
  #===============================================================================
  # This does not work with too many possible combinations, as it will exceed memory capacity
  
  dec_rules$rpart$combinations <- do.call(expand.grid, dec_rules$rpart$var_seq)
  
  #===============================================================================
  # Calculate sum of differences between this variable combination from globally optimal combination
  #===============================================================================
  
  # Create list to store values
  diff_vars <- vector(mode = "list", length = length(vars))
  k = 0
  
  for (i in 1:nrow(dec_rules$rpart$frame)) {
    
    # Only look at nodes which are followed by decisions, not final leaves
    if (dec_rules$rpart$frame[i, "var"] != "<leaf>") {
      
      k = k + 1
      
      # First we need to find the value of the optimal value in the global tree
      opt_var <- ceiling(dec_rules$rpart$frame[i, "index"])
      
      # For that value, we calculate absolute difference between the variables
      diff_vars[[k]] = abs(dec_rules$rpart$combinations[,k] - opt_var)
      
    }
    
  }
  
  # Sum up differences of all vectors to get total difference from globally optimal variables
  dec_rules$rpart$combinations_diff <- Reduce(`+`, diff_vars)
  
  #===============================================================================
  # End
  #===============================================================================
  
  # Return list with output
  
  return(dec_rules)
  
}
  